#!/bin/bash
#
# Provisioner Unified Setup Script
#
# Single-command setup that:
#   1. Installs system deps and provisioner
#   2. Collects device credentials
#   3. Prepares network for switch detection
#   4. Waits for MikroTik switch to be plugged in
#   5. Configures the switch
#   6. Verifies management network
#   7. Starts services and shows ready banner
#
# Usage:
#   sudo bash scripts/setup.sh
#

set -e

# --- Configuration ---
INSTALL_DIR="/opt/provisioner"
CONFIG_DIR="/etc/provisioner"
ENV_FILE="${CONFIG_DIR}/provisioner.env"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
LOG_FILE="/var/log/provisioner-setup.log"
INTERFACE="eth0"
MGMT_VLAN_IFACE="${INTERFACE}.1990"
SWITCH_DEFAULT_IP="192.168.88.1"
PI_MGMT_IP="192.168.88.10"

# --- Colors ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# --- Logging ---
log_step() { echo -e "\n${CYAN}${BOLD}$1${NC}"; echo "[$(date)] STEP: $1" >> "$LOG_FILE"; }
log_info() { echo -e "  ${GREEN}✓${NC} $1"; echo "[$(date)] INFO: $1" >> "$LOG_FILE"; }
log_warn() { echo -e "  ${YELLOW}!${NC} $1"; echo "[$(date)] WARN: $1" >> "$LOG_FILE"; }
log_error() { echo -e "  ${RED}✗${NC} $1"; echo "[$(date)] ERROR: $1" >> "$LOG_FILE"; }
log_detail() { echo -e "  ${DIM}$1${NC}"; }

# --- Helpers ---

check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}Error: This script must be run as root (use sudo)${NC}"
        exit 1
    fi
}

# Read a value from the existing .env file
read_env_value() {
    local key=$1
    if [[ -f "$ENV_FILE" ]]; then
        grep -E "^${key}=" "$ENV_FILE" 2>/dev/null | cut -d= -f2-
    fi
}

# Prompt for a password, showing masked current value
prompt_password() {
    local label=$1
    local env_key=$2
    local current
    current=$(read_env_value "$env_key")

    if [[ -n "$current" && "$current" != "your_"* ]]; then
        local masked="${current:0:2}$(printf '*%.0s' $(seq 1 $((${#current} - 2))))"
        read -rsp "  ${label} [${masked}]: " value
    else
        read -rsp "  ${label}: " value
    fi
    echo ""

    if [[ -n "$value" ]]; then
        echo "$value"
    else
        echo "$current"
    fi
}

# Write or update a key in the .env file
set_env_value() {
    local key=$1
    local value=$2
    mkdir -p "$CONFIG_DIR"

    if [[ -f "$ENV_FILE" ]] && grep -q "^${key}=" "$ENV_FILE"; then
        sed -i "s|^${key}=.*|${key}=${value}|" "$ENV_FILE"
    elif [[ -f "$ENV_FILE" ]]; then
        echo "${key}=${value}" >> "$ENV_FILE"
    else
        cat > "$ENV_FILE" << EOF
# Network Device Provisioner Environment Variables
# Generated by setup.sh

# Device passwords
CAMBIUM_PASSWORD=
TARANA_PASSWORD=
TACHYON_PASSWORD=
MIKROTIK_PASSWORD=

# Notification webhooks (optional)
SLACK_WEBHOOK_URL=
DISCORD_WEBHOOK_URL=
EOF
        sed -i "s|^${key}=.*|${key}=${value}|" "$ENV_FILE"
    fi
    chmod 600 "$ENV_FILE"
}

# Retry wrapper — runs a step function, offers retry on failure
run_step() {
    local step_func=$1
    while true; do
        if $step_func; then
            return 0
        fi
        echo ""
        read -rp "  Retry this step? [Y/n]: " retry
        if [[ "$retry" =~ ^[Nn]$ ]]; then
            return 1
        fi
    done
}

# ============================================================
# Step 1: Install system dependencies and provisioner
# ============================================================
step_install() {
    log_step "[1/7] Installing system dependencies and provisioner"

    if [[ ! -f "${REPO_DIR}/scripts/install.sh" ]]; then
        log_error "Cannot find install.sh at ${REPO_DIR}/scripts/"
        return 1
    fi

    bash "${REPO_DIR}/scripts/install.sh" install
    log_info "Installation complete"
}

# ============================================================
# Step 2: Configure device credentials
# ============================================================
step_credentials() {
    log_step "[2/7] Configure device credentials"
    echo ""
    echo -e "  These passwords are used to log into devices during provisioning."
    echo -e "  Press Enter to keep existing values."
    echo ""

    local cambium_pw tarana_pw tachyon_pw

    cambium_pw=$(prompt_password "Cambium password" "CAMBIUM_PASSWORD")
    tarana_pw=$(prompt_password "Tarana password" "TARANA_PASSWORD")
    tachyon_pw=$(prompt_password "Tachyon password" "TACHYON_PASSWORD")

    [[ -n "$cambium_pw" ]] && set_env_value "CAMBIUM_PASSWORD" "$cambium_pw"
    [[ -n "$tarana_pw" ]] && set_env_value "TARANA_PASSWORD" "$tarana_pw"
    [[ -n "$tachyon_pw" ]] && set_env_value "TACHYON_PASSWORD" "$tachyon_pw"

    log_info "Credentials saved to ${ENV_FILE}"
}

# ============================================================
# Step 3: Prepare network for switch detection
# ============================================================
step_prep_network() {
    log_step "[3/7] Preparing network for switch detection"

    # If the management VLAN already has the right IP, skip
    if ip addr show "$MGMT_VLAN_IFACE" 2>/dev/null | grep -q "${PI_MGMT_IP}"; then
        log_info "Management VLAN ${MGMT_VLAN_IFACE} already has ${PI_MGMT_IP} — skipping"
        return 0
    fi

    # Ensure eth0 is up
    ip link set "$INTERFACE" up 2>/dev/null || true

    # Add temporary IP so we can reach the switch at its factory default
    if ip addr show "$INTERFACE" 2>/dev/null | grep -q "${PI_MGMT_IP}"; then
        log_info "Temporary IP ${PI_MGMT_IP} already on ${INTERFACE}"
    else
        ip addr add "${PI_MGMT_IP}/24" dev "$INTERFACE" 2>/dev/null || true
        log_info "Added temporary ${PI_MGMT_IP}/24 on ${INTERFACE}"
    fi

    log_detail "This lets us reach the switch at ${SWITCH_DEFAULT_IP} before VLANs are active."
}

# ============================================================
# Step 4: Wait for MikroTik switch
# ============================================================
step_wait_switch() {
    log_step "[4/7] Waiting for MikroTik switch"

    # Check if already reachable
    if ping -c1 -W1 "$SWITCH_DEFAULT_IP" &>/dev/null; then
        log_info "Switch already reachable at ${SWITCH_DEFAULT_IP}"
        return 0
    fi

    echo ""
    echo -e "  Plug your MikroTik switch into the OrangePi ethernet port now."
    echo -e "  Scanning for switch at ${SWITCH_DEFAULT_IP}..."
    echo ""

    local elapsed=0
    local timeout=300
    local spinner='|/-\'

    trap 'echo ""; log_warn "Skipped switch wait (Ctrl+C)"; return 0' INT

    while [[ $elapsed -lt $timeout ]]; do
        if ping -c1 -W1 "$SWITCH_DEFAULT_IP" &>/dev/null; then
            echo ""
            log_info "Switch detected at ${SWITCH_DEFAULT_IP}"
            trap - INT
            return 0
        fi

        local si=$(( elapsed % 4 ))
        printf "\r  Waiting... [%3ds] %s" "$elapsed" "${spinner:$si:1}"
        sleep 2
        elapsed=$((elapsed + 2))
    done

    trap - INT
    echo ""
    log_error "Timed out after ${timeout}s waiting for switch at ${SWITCH_DEFAULT_IP}"
    echo ""
    echo "  Make sure:"
    echo "    - The switch is powered on"
    echo "    - An ethernet cable connects the switch to the OrangePi"
    echo "    - The switch is at factory defaults (192.168.88.1)"
    echo ""
    return 1
}

# ============================================================
# Step 5: Configure MikroTik switch
# ============================================================
step_configure_switch() {
    log_step "[5/7] Configuring MikroTik switch"

    echo ""
    echo -e "  New MikroTik switches use ${BOLD}admin${NC} with no password."
    read -rp "  Switch username [admin]: " switch_user
    switch_user=${switch_user:-admin}

    read -rsp "  Switch password (Enter for none): " switch_pass
    echo ""

    # Test SSH connection first
    local ssh_opts="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -o LogLevel=ERROR"
    local test_ok=false

    for attempt in 1 2 3; do
        log_detail "Testing SSH connection (attempt ${attempt}/3)..."
        local test_cmd="/system identity print"
        local result=""

        if [[ -z "$switch_pass" ]]; then
            result=$(ssh $ssh_opts "${switch_user}@${SWITCH_DEFAULT_IP}" "$test_cmd" 2>/dev/null) && test_ok=true && break
        else
            result=$(sshpass -p "$switch_pass" ssh $ssh_opts "${switch_user}@${SWITCH_DEFAULT_IP}" "$test_cmd" 2>/dev/null) && test_ok=true && break
        fi
        sleep 2
    done

    if [[ "$test_ok" != true ]]; then
        log_error "Cannot connect to switch via SSH"
        echo "  Check username/password and that SSH is enabled on the switch."
        return 1
    fi

    log_info "SSH connection successful"

    # Check if already configured
    if echo "$result" | grep -q "provisioner-switch"; then
        echo ""
        read -rp "  Switch appears already configured. Re-configure? [y/N]: " reconfig
        if [[ ! "$reconfig" =~ ^[Yy]$ ]]; then
            log_info "Skipping switch configuration"
            return 0
        fi
    fi

    # Run setup_switch.sh
    local switch_args=(--ip "$SWITCH_DEFAULT_IP" --username "$switch_user" --yes)
    if [[ -n "$switch_pass" ]]; then
        switch_args+=(--password "$switch_pass")
    else
        switch_args+=(--password "")
    fi

    bash "${REPO_DIR}/scripts/setup_switch.sh" "${switch_args[@]}"

    log_info "Switch configuration applied"

    # Wait for switch to apply VLAN changes
    log_detail "Waiting 15s for switch to apply VLAN configuration..."
    sleep 15
}

# ============================================================
# Step 6: Verify management network
# ============================================================
step_verify_network() {
    log_step "[6/7] Verifying management network"

    # Remove temporary IP from raw eth0 (if present)
    if ip addr show "$INTERFACE" 2>/dev/null | grep -q "${PI_MGMT_IP}/24"; then
        ip addr del "${PI_MGMT_IP}/24" dev "$INTERFACE" 2>/dev/null || true
        log_detail "Removed temporary IP from ${INTERFACE}"
    fi

    # Create the management VLAN interface if it doesn't exist
    if ! ip link show "$MGMT_VLAN_IFACE" &>/dev/null; then
        modprobe 8021q 2>/dev/null || true
        ip link add link "$INTERFACE" name "$MGMT_VLAN_IFACE" type vlan id 1990
        log_detail "Created ${MGMT_VLAN_IFACE}"
    fi

    ip link set "$MGMT_VLAN_IFACE" up
    if ! ip addr show "$MGMT_VLAN_IFACE" 2>/dev/null | grep -q "${PI_MGMT_IP}"; then
        ip addr add "${PI_MGMT_IP}/24" dev "$MGMT_VLAN_IFACE" 2>/dev/null || true
    fi

    # Ping switch through the management VLAN
    log_detail "Pinging switch at ${SWITCH_DEFAULT_IP} via ${MGMT_VLAN_IFACE}..."

    local ok=false
    for attempt in $(seq 1 6); do
        if ping -c1 -W2 -I "$MGMT_VLAN_IFACE" "$SWITCH_DEFAULT_IP" &>/dev/null; then
            ok=true
            break
        fi
        log_detail "Retry ${attempt}/6..."
        sleep 5
    done

    if [[ "$ok" == true ]]; then
        log_info "Management VLAN working — switch reachable via ${MGMT_VLAN_IFACE}"
    else
        log_warn "Cannot reach switch via management VLAN yet"
        log_warn "This may resolve after a reboot. Continuing anyway."
    fi
}

# ============================================================
# Step 7: Start services and show ready banner
# ============================================================
step_start_services() {
    log_step "[7/7] Starting services"

    systemctl daemon-reload
    systemctl enable provisioner-web 2>/dev/null || true
    systemctl restart provisioner-web

    # Wait for service to start
    local started=false
    for i in $(seq 1 15); do
        if systemctl is-active --quiet provisioner-web; then
            started=true
            break
        fi
        sleep 1
    done

    if [[ "$started" == true ]]; then
        log_info "provisioner-web service is running"
    else
        log_warn "Service may not have started — check: journalctl -u provisioner-web -f"
    fi

    # Detect IP for banner
    local pi_ip
    pi_ip=$(ip -br addr show "$INTERFACE" 2>/dev/null | awk '{print $3}' | cut -d/ -f1 | head -1)
    pi_ip=${pi_ip:-"<device-ip>"}

    echo ""
    echo -e "  ${GREEN}${BOLD}╔══════════════════════════════════════════╗${NC}"
    echo -e "  ${GREEN}${BOLD}║         PROVISIONER READY                ║${NC}"
    echo -e "  ${GREEN}${BOLD}╠══════════════════════════════════════════╣${NC}"
    echo -e "  ${GREEN}${BOLD}║${NC}                                          ${GREEN}${BOLD}║${NC}"
    echo -e "  ${GREEN}${BOLD}║${NC}  Web UI:  ${CYAN}http://${pi_ip}:8080${NC}$(printf '%*s' $((18 - ${#pi_ip})) '')${GREEN}${BOLD}║${NC}"
    echo -e "  ${GREEN}${BOLD}║${NC}                                          ${GREEN}${BOLD}║${NC}"
    echo -e "  ${GREEN}${BOLD}║${NC}  Port 1-6   Provisioning devices         ${GREEN}${BOLD}║${NC}"
    echo -e "  ${GREEN}${BOLD}║${NC}  Port 7     WAN / Internet               ${GREEN}${BOLD}║${NC}"
    echo -e "  ${GREEN}${BOLD}║${NC}  Port 8     OrangePi (trunk)             ${GREEN}${BOLD}║${NC}"
    echo -e "  ${GREEN}${BOLD}║${NC}                                          ${GREEN}${BOLD}║${NC}"
    echo -e "  ${GREEN}${BOLD}║${NC}  Plug devices into ports 1-6 to start.   ${GREEN}${BOLD}║${NC}"
    echo -e "  ${GREEN}${BOLD}╚══════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "  Logs:  ${DIM}journalctl -u provisioner-web -f${NC}"
    echo ""
}

# ============================================================
# Main
# ============================================================
main() {
    check_root

    # Init log file
    mkdir -p "$(dirname "$LOG_FILE")"
    echo "=== Provisioner setup started $(date) ===" >> "$LOG_FILE"

    echo ""
    echo -e "${BOLD}  Network Device Provisioner — Setup${NC}"
    echo -e "${DIM}  Log: ${LOG_FILE}${NC}"
    echo ""

    run_step step_install        || { log_error "Installation failed"; exit 1; }
    run_step step_credentials    || log_warn "Skipped credentials — edit ${ENV_FILE} later"
    run_step step_prep_network   || { log_error "Network prep failed"; exit 1; }
    run_step step_wait_switch    || log_warn "Skipped switch wait"
    run_step step_configure_switch || log_warn "Skipped switch config — run scripts/setup_switch.sh later"
    run_step step_verify_network || log_warn "Network verification had issues"
    step_start_services

    echo "[$(date)] Setup complete" >> "$LOG_FILE"
}

main "$@"
